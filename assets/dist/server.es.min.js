function P(n){return n<0n&&(n*=-1n),n}function w(n,t){if(n===0n)return{g:t,x:0n,y:1n};{let{g:e,x:r,y:i}=w(t%n,n);return{g:e,x:i-t/n*r,y:r}}}function h(n,t){if(t<=0n)throw new Error("m must be > 0");const e=n%t;return e<0n?e+t:e}function b(n,t){return h(n,t)}function N(n,t){const e=w(h(n,t),t);if(e.g!==1n)throw new Error("Modular inverse does not exist");return h(e.x,t)}function m(n){return n%2n===1n}function c(n,t,e){if(e===0n)throw new Error("Cannot modPow with modulus 0");if(t===0n)return 1n;if(n=h(n,e),t<0n)return N(c(n,P(t),e),e);let r=1n;for(;t>0n;){if(n===0n)return 0n;m(t)&&(r=r*n%e),t=t/2n,n=n*n%e}return r}function T(n){if(typeof process=="object"&&typeof require=="function"){const{randomBytes:t}=require("crypto");return new Uint8Array(t(n))}else{const t=new Uint8Array(n);return window.crypto.getRandomValues(t),t}}function U(n){return n.length%2!==0&&(n="0"+n),n}function y(n,t=!1){let e=n.toString(16);return t?U(e):e}function I(n){return y(n,!0)}function L(n){const t=n.length/2,e=new Uint8Array(t);for(let r=0,i=0;r<t;r++,i+=2)e[r]=parseInt(n.slice(i,i+2),16);return e}function p(n,t=!1){if(n<0n)if(t){const r=1n<<(BigInt(n.toString(2).length)/8n+1n)*8n;n+=r}else throw new Error("BigInt should larger than 0 to convert to Uint8Array");return L(I(n))}function v(n){const t=n.startsWith("-");t&&(n=n.substring(1));let e=BigInt("0x"+n);return t?-e:e}function a(n,t=10){if(typeof n=="bigint")return n;if(typeof n=="number"||t===10)return BigInt(n);if(t===16)return v(n);{let e=0n;for(let r=0;r<n.length;r++){const i=parseInt(n[r],t);if(isNaN(i))throw new Error("Invalid character for base: "+t);e=e*BigInt(t)+BigInt(i)}return e}}function S(n,t=!1){let e=0n;const r=t&&(n[0]&128)!==0;if(r){for(let s=0;s<n.length;s++)n[s]=~n[s]&255;let i=1;for(let s=n.length-1;s>=0&&i>0;s--){const o=n[s]+i;n[s]=o&255,i=o>>8}}for(let i=0;i<n.length;i++)e=(e<<8n)+BigInt(n[i]);return r?-e:e}function x(n,t=!1){return y(S(n,t))}class H extends Error{}const k=21766174458617435773191008891802753781907668374255538511144643224689886235383840957210909013086056401571399717235807266581649606472148410291413364152197364477180887395655483738115072677402235101762521901569820740293149529620419333266262073471054548368736039519702486226506248861060256971802984953561121442680157668000761429988222457090413873973970171927093992114751765168063614761119615476233422096442783117971236371647333871414335895773474667308967050807005509320424799678417036867928316761272274230314067548291133582479583061439577559347101961771406173684378522703483495337037655006751328447510550299250924469288819n,q=2n,C=a("5b9e8ef059c6b32ea59fc1d322d37f04aa30bae5aa9003b8321e21ddb04e300",16);function R(n,t){if(E()){const{timingSafeEqual:o}=require("crypto");return o(f(n),f(t))}const e=String(n);let r=String(t);const i=e.length;let s=0;i!==r.length&&(r=e,s=1);for(let o=0;o<i;o++)s|=e.charCodeAt(o)^r.charCodeAt(o);return s===0}function E(){return typeof window>"u"}function f(n){let t;return typeof window>"u"?t=Buffer.from(n,"utf-8"):t=new TextEncoder().encode(n),t}function M(...n){let t=n.reduce((i,s)=>i+s.byteLength,0),e=new Uint8Array(t),r=0;for(let i of n)e.set(new Uint8Array(i),r),r+=i.byteLength;return e}class G{constructor(t,e,r){this.prime=t,this.generator=e,this.key=r,this.length=256/8,this.hasher="sha256",this.padEnabled=!0}setHasher(t){return this.hasher=t,this}async generateRandomSecret(){return S(T(this.getLength()))}getLength(){return this.length}setLength(t){return this.length=t,this}setSize(t){return this.setLength(Math.floor(t/8))}async generateCommonSecret(t,e){return this.checkNotEmpty(t,"A"),this.checkNotEmpty(e,"B"),this.hash(this.pad(t),this.pad(e))}async generateClientSessionProof(t,e,r,i,s){return await this.hash(await this.hash(this.getPrime())^await this.hash(this.getGenerator()),await this.hash(t),e,r,i,s)}async generateServerSessionProof(t,e,r){return this.hash(t,e,r)}getPrime(){return this.prime}getGenerator(){return this.generator}getKey(){return this.key}async hash(...t){const e=t.map(i=>typeof i=="bigint"?p(i):f(i)),r=await this.hashToString(M(...e));return a(r,16)}async hashToString(t){let e=this.hasher;typeof e=="string"&&(e=this.getHasherByName(e));let r=await e(t,this.getLength());return r instanceof Uint8Array&&(r=x(r)),r}getHasherByName(t){return t=t.toLowerCase(),async e=>{if(E()){const{createHash:r}=require("crypto");return new Uint8Array(Buffer.from(r(t).update(Buffer.from(e)).digest("hex"),"hex"))}switch(t){case"sha1":return new Uint8Array(await crypto.subtle.digest("SHA-1",e));case"sha256":return new Uint8Array(await crypto.subtle.digest("SHA-256",e));case"sha384":return new Uint8Array(await crypto.subtle.digest("SHA-384",e));case"sha512":return new Uint8Array(await crypto.subtle.digest("SHA-512",e))}throw new Error("Available hasher not found.")}}checkNotEmpty(t,e){if(!t)throw new Error(`Value: \`${e}\` should not be empty.`);if(typeof t=="bigint"&&t===0n)throw new Error(`Value: \`${e}\` should not be zero.`)}pad(t){if(!this.padEnabled)return t;const e=this.intToBytes(this.getPrime()).length,r=t.toString(16).padStart(e,"0");return BigInt("0x"+r)}intToBytes(t){return new TextDecoder().decode(p(t))}timingSafeEquals(t,e){return R(t,e)}isPadEnabled(){return this.padEnabled}enablePad(t=!0){return this.padEnabled=!!t,this}}class D extends G{static create(t,e,r){return t??(t=k),e??(e=q),r??(r=C),new this(a(t,16),a(e,16),a(r,16))}async step1(t,e,r){this.checkNotEmpty(t,"identity"),this.checkNotEmpty(e,"salt"),this.checkNotEmpty(r,"verifier");const i=await this.generateRandomSecret(),s=await this.generatePublic(i,r);return{secret:i,public:s}}async step2(t,e,r,i,s,o,g){this.checkNotEmpty(i,"A"),this.checkNotEmpty(g,"M1");const A=await this.generateCommonSecret(i,o),l=await this.generatePreMasterSecret(i,s,r,A),u=await this.hash(l),d=await this.generateClientSessionProof(t,e,i,o,u);if(!this.timingSafeEquals(d.toString(),g.toString()))throw new H("Invalid client session proof.");const B=await this.generateServerSessionProof(i,d,u);return{key:u,proof:B,preMasterSecret:l}}generatePublic(t,e){const r=this.getPrime();return b(this.getKey()*e+c(this.getGenerator(),t,r),r)}generatePreMasterSecret(t,e,r,i){const s=this.getPrime();return c(c(r,i,s)*t,e,s)}}export{D as default};
//# sourceMappingURL=server.es.min.js.map
