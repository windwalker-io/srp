function b(r){return r<0n&&(r*=-1n),r}function A(r,t){if(r===0n)return{g:t,x:0n,y:1n};{let{g:e,x:n,y:i}=A(t%r,r);return{g:e,x:i-t/r*n,y:n}}}function l(r,t){if(t<=0n)throw new Error("m must be > 0");const e=r%t;return e<0n?e+t:e}function m(r,t){return l(r,t)}function H(r,t){const e=A(l(r,t),t);if(e.g!==1n)throw new Error("Modular inverse does not exist");return l(e.x,t)}function L(r){return r%2n===1n}function h(r,t,e){if(e===0n)throw new Error("Cannot modPow with modulus 0");if(t===0n)return 1n;if(r=l(r,e),t<0n)return H(h(r,b(t),e),e);let n=1n;for(;t>0n;){if(r===0n)return 0n;L(t)&&(n=n*r%e),t=t/2n,r=r*r%e}return n}function B(r){if(typeof process=="object"&&typeof require=="function"){const{randomBytes:t}=require("crypto");return new Uint8Array(t(r))}else{const t=new Uint8Array(r);return window.crypto.getRandomValues(t),t}}function M(r){return r.length%2!==0&&(r="0"+r),r}function d(r,t=!1){let e=r.toString(16);return t?M(e):e}function C(r){return d(r,!0)}function R(r){const t=r.length/2,e=new Uint8Array(t);for(let n=0,i=0;n<t;n++,i+=2)e[n]=parseInt(r.slice(i,i+2),16);return e}function v(r,t=!1){if(r<0n)if(t){const n=1n<<(BigInt(r.toString(2).length)/8n+1n)*8n;r+=n}else throw new Error("BigInt should larger than 0 to convert to Uint8Array");return R(C(r))}function N(r){const t=r.startsWith("-");t&&(r=r.substring(1));let e=BigInt("0x"+r);return t?-e:e}function c(r,t=10){if(typeof r=="bigint")return r;if(typeof r=="number"||t===10)return BigInt(r);if(t===16)return N(r);{let e=0n;for(let n=0;n<r.length;n++){const i=parseInt(r[n],t);if(isNaN(i))throw new Error("Invalid character for base: "+t);e=e*BigInt(t)+BigInt(i)}return e}}function w(r,t=!1){let e=0n;const n=t&&(r[0]&128)!==0;if(n){for(let s=0;s<r.length;s++)r[s]=~r[s]&255;let i=1;for(let s=r.length-1;s>=0&&i>0;s--){const a=r[s]+i;r[s]=a&255,i=a>>8}}for(let i=0;i<r.length;i++)e=(e<<8n)+BigInt(r[i]);return n?-e:e}function k(r,t=!1){return d(w(r,t))}const y=21766174458617435773191008891802753781907668374255538511144643224689886235383840957210909013086056401571399717235807266581649606472148410291413364152197364477180887395655483738115072677402235101762521901569820740293149529620419333266262073471054548368736039519702486226506248861060256971802984953561121442680157668000761429988222457090413873973970171927093992114751765168063614761119615476233422096442783117971236371647333871414335895773474667308967050807005509320424799678417036867928316761272274230314067548291133582479583061439577559347101961771406173684378522703483495337037655006751328447510550299250924469288819n,S=2n,p=c("5b9e8ef059c6b32ea59fc1d322d37f04aa30bae5aa9003b8321e21ddb04e300",16);function q(r){return N(r)}function G(r,t=!1){return d(r,t)}function T(r,t){if(I()){const{timingSafeEqual:a}=require("crypto");return a(E(r),E(t))}const e=String(r);let n=String(t);const i=e.length;let s=0;i!==n.length&&(n=e,s=1);for(let a=0;a<i;a++)s|=e.charCodeAt(a)^n.charCodeAt(a);return s===0}function I(){return typeof window>"u"}function E(r){let t;return typeof window>"u"?t=Buffer.from(r,"utf-8"):t=new TextEncoder().encode(r),t}function K(...r){let t=r.reduce((i,s)=>i+s.byteLength,0),e=new Uint8Array(t),n=0;for(let i of r)e.set(new Uint8Array(i),n),n+=i.byteLength;return e}class U{constructor(t,e,n){this.prime=t,this.generator=e,this.key=n,this.length=256/8,this.hasher="sha256",this.padEnabled=!0}setHasher(t){return this.hasher=t,this}async generateRandomSecret(){return w(B(this.getLength()))}getLength(){return this.length}setLength(t){return this.length=t,this}setSize(t){return this.setLength(Math.floor(t/8))}async generateCommonSecret(t,e){return this.checkNotEmpty(t,"A"),this.checkNotEmpty(e,"B"),this.hash(this.pad(t),this.pad(e))}async generateClientSessionProof(t,e,n,i,s){return await this.hash(await this.hash(this.getPrime())^await this.hash(this.getGenerator()),await this.hash(t),e,n,i,s)}async generateServerSessionProof(t,e,n){return this.hash(t,e,n)}getPrime(){return this.prime}getGenerator(){return this.generator}getKey(){return this.key}async hash(...t){const e=t.map(i=>typeof i=="bigint"?v(i):E(i)),n=await this.hashToString(K(...e));return c(n,16)}async hashToString(t){let e=this.hasher;typeof e=="string"&&(e=this.getHasherByName(e));let n=await e(t,this.getLength());return n instanceof Uint8Array&&(n=k(n)),n}getHasherByName(t){return t=t.toLowerCase(),async e=>{if(I()){const{createHash:n}=require("crypto");return new Uint8Array(Buffer.from(n(t).update(Buffer.from(e)).digest("hex"),"hex"))}switch(t){case"sha1":return new Uint8Array(await crypto.subtle.digest("SHA-1",e));case"sha256":return new Uint8Array(await crypto.subtle.digest("SHA-256",e));case"sha384":return new Uint8Array(await crypto.subtle.digest("SHA-384",e));case"sha512":return new Uint8Array(await crypto.subtle.digest("SHA-512",e))}throw new Error("Available hasher not found.")}}checkNotEmpty(t,e){if(!t)throw new Error(`Value: \`${e}\` should not be empty.`);if(typeof t=="bigint"&&t===0n)throw new Error(`Value: \`${e}\` should not be zero.`)}pad(t){if(!this.padEnabled)return t;const e=this.intToBytes(this.getPrime()).length,n=t.toString(16).padStart(e,"0");return BigInt("0x"+n)}intToBytes(t){return new TextDecoder().decode(v(t))}timingSafeEquals(t,e){return T(t,e)}isPadEnabled(){return this.padEnabled}enablePad(t=!0){return this.padEnabled=!!t,this}}class V extends U{static create(t,e,n){return t??(t=y),e??(e=S),n??(n=p),new this(c(t,16),c(e,16),c(n,16))}async register(t,e){const n=await this.generateSalt(),i=await this.generatePasswordHash(n,t,e),s=await this.generateVerifier(i);return{salt:n,verifier:s}}async step1(t,e,n){const i=await this.generateRandomSecret(),s=await this.generatePublic(i),a=await this.generatePasswordHash(n,t,e);return{secret:i,public:s,hash:a}}async step2(t,e,n,i,s,a){if(s%this.getPrime()===0n)throw new Error("Server may return a invalid public ephemeral.");const u=await this.generateCommonSecret(n,s),o=await this.generatePreMasterSecret(i,s,a,u),g=await this.hash(o),f=await this.generateClientSessionProof(t,e,n,s,g);return{key:g,proof:f,preMasterSecret:o}}async step3(t,e,n,i){if(!await this.verifyServerSession(t,e,n,i))throw new Error("Invalid server session proof.")}async verifyServerSession(t,e,n,i){const s=await this.generateServerSessionProof(t,n,e);return this.timingSafeEquals(s.toString(),i.toString())}async generateSalt(){return w(B(16))}async generatePasswordHash(t,e,n){return await this.hash(t,await this.hash(e+":"+n))}async generatePreMasterSecret(t,e,n,i){const s=this.getPrime(),a=this.getGenerator(),u=this.getKey();let o=e-u*h(a,n,s);return o<0n&&(o=s-b(o),o=m(o,s)),h(o,t+i*n,s)}async generateVerifier(t){return h(this.getGenerator(),t,this.getPrime())}async generatePublic(t){return h(this.getGenerator(),t,this.getPrime())}}class D extends Error{}class Z extends U{static create(t,e,n){return t??(t=y),e??(e=S),n??(n=p),new this(c(t,16),c(e,16),c(n,16))}async step1(t,e,n){this.checkNotEmpty(t,"identity"),this.checkNotEmpty(e,"salt"),this.checkNotEmpty(n,"verifier");const i=await this.generateRandomSecret(),s=await this.generatePublic(i,n);return{secret:i,public:s}}async step2(t,e,n,i,s,a,u){this.checkNotEmpty(i,"A"),this.checkNotEmpty(u,"M1");const o=await this.generateCommonSecret(i,a),g=await this.generatePreMasterSecret(i,s,n,o),f=await this.hash(g),P=await this.generateClientSessionProof(t,e,i,a,f);if(!this.timingSafeEquals(P.toString(),u.toString()))throw new D("Invalid client session proof.");const x=await this.generateServerSessionProof(i,P,f);return{key:f,proof:x,preMasterSecret:g}}generatePublic(t,e){const n=this.getPrime();return m(this.getKey()*e+h(this.getGenerator(),t,n),n)}generatePreMasterSecret(t,e,n,i){const s=this.getPrime();return h(h(n,i,s)*t,e,s)}}export{S as DEFAULT_GENERATOR,p as DEFAULT_KEY,y as DEFAULT_PRIME,V as SRPClient,Z as SRPServer,G as bigintToHex,q as hexToBigint,T as timingSafeEquals};
//# sourceMappingURL=srp.es.min.js.map
